<!DOCTYPE html>
<html>
    <head>



        <meta charset="UTF-8">
        <title>Field Operator</title>


        <style>


body {
    margin: 0;
    padding: 20px;
    background: #000;
    font-family: 'Courier New', monospace;
    color: #00ff00;
    display: flex;
    flex-direction: column;
    align-items: center;
}

#canvas {
    display: block;
    background: #000;
    border: 3px solid #00ff00;
    cursor: crosshair;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
    margin: 20px 0;
}

h1 {
    text-align: center;
    text-shadow: 0 0 15px #00ff00;
    font-size: 2.5em;
    margin: 10px 0;
    letter-spacing: 3px;
}

.info {
    color: #00aa00;
    font-size: 0.9em;
    text-align: center;
    margin-top: 10px;
}
        </style>
    </head>

    <body>
        <h1>âš¡ FIELD OPERATOR âš¡</h1>
        <canvas id="canvas" width="800" height="600"></canvas>
        <div class="info">
            Click: +charge | Shift+Click: -charge
        </div>

        <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');






//coulomb constant


//(i scaled it way down for canvas pixels)

const k = 5000;
const drag = 0.96;  // increased for smoother settling
const phosphor_alpha = 0.12;  // trail fade

class Particle {
    constructor(x, y, q) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;  // was typo: vy - 0
        this.q = q;
        this.trail = [];  // phosphor trail
        this.maxTrail = 20;
    }

    applyForce(charges) {
        for (let c of charges) {
            const dx = this.x - c.x;
            const dy = this.y - c.y;
            const r2 = dx*dx + dy*dy + 10;  // was 1, now 10 (less jitter)

            if (r2 < 100) continue;  // was 0.1, now 100 (fixed jitter near charges!)
            const r = Math.sqrt(r2);

            const force = k * this.q * c.q / r2;

            this.vx += force * dx/r * 0.001;
            this.vy += force * dy/r * 0.001;
        }
    }

    update() {
        this.vx *= drag;
        this.vy *= drag;
        this.x += this.vx;
        this.y += this.vy;
        
        // Update trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrail) {
            this.trail.shift();
        }
    }

    draw() {
        // Draw phosphor trail
        if (this.trail.length > 1) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.globalAlpha = phosphor_alpha;
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
        
        // Draw particle
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
    }
}


console.log('particle phy loaded');

// Arrays for particles and charges
let particles = [];
let charges = [];

// Spawn 2000 neutral particles
for (let i = 0; i < 2000; i++) {
    particles.push(new Particle(
        Math.random() * 800,
        Math.random() * 600,
        0  // neutral charge
    ));
}
console.log('ðŸ§² spawned 2000 particles');

// Mouse click to place charges
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const q = e.shiftKey ? -1 : 1;  // shift = negative
    
    charges.push({ x, y, q });
    console.log(`âš¡ placed ${q > 0 ? '+' : '-'} charge at (${x.toFixed(0)}, ${y.toFixed(0)})`);
});

// Animation loop
function animate() {
    // Darker fade for better phosphor trails
    ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
    ctx.fillRect(0, 0, 800, 600);
    
    // Update particles
    for (let p of particles) {
        p.applyForce(charges);
        p.update();
        
        // Bounce off edges
        if (p.x < 0) p.x = 0, p.vx *= -0.5;
        if (p.x > 800) p.x = 800, p.vx *= -0.5;
        if (p.y < 0) p.y = 0, p.vy *= -0.5;
        if (p.y > 600) p.y = 600, p.vy *= -0.5;
        
        p.draw();
    }
    
    // Draw charges with better glow
    for (let c of charges) {
        const color = c.q > 0 ? '#ff0000' : '#0000ff';
        
        // Outer glow
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.15;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Middle glow
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        // Charge core
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Label
        ctx.fillStyle = '#fff';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(c.q > 0 ? '+' : 'âˆ’', c.x, c.y);
    }
    
    requestAnimationFrame(animate);
}

animate();
console.log('âœ… animation started');
        </script>
        </body>
</html>